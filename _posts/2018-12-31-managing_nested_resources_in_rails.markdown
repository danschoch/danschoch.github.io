---
layout: post
title:      "Managing Nested Resources in Rails"
date:       2018-12-31 20:24:09 -0500
permalink:  managing_nested_resources_in_rails
---


Nested resources are a powerful tool for utilizing nested routes while keeping your routes file itself clean, DRY, and easy-to-read. However, numerous blogs, courses, and Stack Overflow threads will tell you that nested resources quickly become unwieldy if you choose to nest more than one layer down from the original resource. I came across this problem when I was recently building a Rails application and found a nifty solution: the "shallow" option.

## What are Nested Resources?
For those who are unfamiliar with the concept, here are the basics behind the concept of nested resources. When you have a parent/child relationship between models, dynamic route segments can give you access to the id of the parent model via the url and parameters hash made available by rails. For instance, in my recent Rails project, I was building a project management application. The first level of parent/child relationships I needed to manage was Projects that were comprised of many Tasks. Since a Task was meant to be inseparable from the Project for which it was created, having dynamic route segments made sense so as to demonstrate the two models' relationship. Routes with dynamic route segments might look like this.
```
get 'projects/:id/tasks', to: 'project#tasks_index'
get 'projects/:id/tasks/:id', to: 'projects#tasks'

```

Unlike the standard RESTful routes that would be generated by Rails with `resources :tasks` , these dynamic routes clearly show the relationship between Projects and Tasks. Furthermore, whenever creating a new task, I would now access to the project id via `params[:project_id]`. That's one less variable that I would have to define and pass around the controllers and views involved in these actions.

Nested resources takes this thinking one step further. Obviously, I only drew two routes in the example above, and would have a few more to have a full assortment of CRUD actions. Rails allows us to use the resources helper in conjunction with nesting to DRY up our code and make the relationship even clearer in our routes file. To have a full complement of RESTful routes for both models, I simply add this to my routes file:
```
resources :projects do
   resources :tasks
end
```

There is, of course, some work to be done in your controllers to properly finish setting up the actions that correspond to these routes, but that's pretty much it! Now you have the full complement of RESTful routes for the Project and Task Models, including routes for the Task model that give you access to its corresponding project's id.


## The Problem With More Than Two Layers

My application called for another model realtionship, with each Task having multiple Comments attached to it. It would seem that maybe I should continue down the nesting rabbit hole by nesting the comments resource under that of the tasks, as such:
```
resources :projects do
   resources :tasks do
	    resources :comments
	 end
end

```

One of the main problems with this approach is that your URL's and paths will quickly become confusing and burdensome with this approach. For instance, to show an individual comment that was routed like this, I would follow the url `/projects/:id/tasks/:id/comments/:id` and any time you wished to make use of the path helpers afforded by rails, it would look like  `project_task_comment_path(project_id, task_id, comment_id)`. This quickly starts to become more confusing and difficult to maintain than it would be if we tried some other method of managing these model relationships.

AN IMPORTANT CAVEAT BEFORE MOVING ON: Often times, nesting more than one level deep is discouraged not only for the aforementioned reasons, but also because it violates the separation of concerns principle. In my example, are comments really the concern of projects? If they are not, nesting the comments resource under the projects resource really doesn't make any sense. For reasons I won't go into here, I decided I would like to have all three sets of routes nested together if I could find a way to make it manageable. 

## The Solution: The "Shallow" Option

After a bit of googling, the solution presented itself in the form of an option that you can pass to the `resources` helper called `shallow`. Shallow basically generatesthe actions the collection actions that should be nested under the parent (i.e. index, new, and create actions) as the nested resources do above, but generates the remaining routes and actions outside of the scope of the parent. Using the example of the Project and Task models from above, the syntax would look like this:
```
resources :projects do
  resources :tasks, shallow: true
end
```
and would result in the following routes for the Projects or Tasks controller to take advantage of:
```
project           GET    /projects/:project_id/tasks(.:format)                                    tasks#index
                          POST   /projects/:project_id/tasks(.:format)                                  tasks#create
                          GET    /projects/:project_id/tasks/new(.:format)                           tasks#new
                          GET    /tasks/:id/edit(.:format)                                                               tasks#edit
                          GET    /tasks/:id(.:format)                                                                        tasks#show
                          PATCH  /tasks/:id(.:format)                                                                     tasks#update
                          PUT    /tasks/:id(.:format)                                                                        tasks#update
                          DELETE /tasks/:id(.:format)                                                                    tasks#destroy
```

Ultimately, I ended up structuring my routes like this:
```
resources :projects, shallow: true do
    resources :tasks do
      resources :comments
    end
  end
```

Adding the shallow option to the top level applies it to each line below it, which meant that ultimately my routes for the Comment model, which could have been EXTREMELY messy, looked like this:
```
 task_comments GET    /tasks/:task_id/comments(.:format)                                                       comments#index
                                   POST   /tasks/:task_id/comments(.:format)                                                       comments#create new_task_comment GET    /tasks/:task_id/comments/new(.:format)                                                   comments#new
             edit_comment GET    /comments/:id/edit(.:format)                                                             comments#edit
                  comment GET    /comments/:id(.:format)                                                                  comments#show
                          PATCH  /comments/:id(.:format)                                                                  comments#update
                          PUT    /comments/:id(.:format)                                                                  comments#update
                          DELETE /comments/:id(.:format)                                                                  comments#destroy
```

Very managable, yet the way the routes are construed in the `routes.rb` file is also very clear. 

I think this is a nice option for those situtations in which you feel nested routes would be a good option for your application, but in which the standard approach for those routes would be unruly. Hopefully this helps you in your future Rails endeavours!
